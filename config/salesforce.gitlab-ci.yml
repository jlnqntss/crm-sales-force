####################################################
# Salesforce Zurich CI - Pipelines
#
# Adaptación de los pipelines de NTS y la plantilla estándar 
# SF para GitLab
# para Zurich, aplicando estrategia git-flow
#
# author: jmartinezpisson
#
# Variables de entrada
#
# STAGING_SANDBOX_AUTH_URL:
# URL de autenticación SFDX para el entorno SF Staging
#
# QA_SANDBOX_AUTH_URL:
# URL de autenticación SFDX para el entorno SF QA
#
# DEVHUB_AUTH_URL:
# URL de autenticación SFDX para el DevHub de Zurich
#
# TEST_DISABLED: 
# Deshabilita tests preliminares/post-staging
#
# ALLOW_FAILURE
# Permite que las etapas de testing fallen
#
# SFDX_NTS1_GIT_URI
# URI donde se aloja el plugin SFDX NTS1 
# proporcionado por NTS
####################################################

####################################################
# Imagen Docker para los jobs. Puesto que el 
# pipeline es JS, se utiliza node.
####################################################
image: 807625060872.dkr.ecr.eu-west-1.amazonaws.com/capside/node/12


####################################################
# Cachea node modules entre jobs.
# https://docs.gitlab.com/ee/ci/yaml/README.html#cache
####################################################
cache:
  key: ${CI_COMMIT_REF_NAME}
  paths:
    - node_modules/
    - .sfdx/


####################################################
# Etapas del pipeline
#
# Workflow Feature: validate
# Promoción Feature a Dev (MR feat a dev): validate - promotion
# Promoción Dev a QA (release): validate - promotion
# Promoción QA a Prod (tag x.x.x): validate - promotion
####################################################

stages:
 - validate
 - promotion
 - deploy
 - post-deploy
 - release


before_script:
  - npm config set proxy "$HTTP_PROXY"
  - npm config set https-proxy "$HTTPS_PROXY"

################################
## Helpers - Comandos de apoyo
################################

.sfdx_helpers: &sfdx_helpers |

  # Instala las herramientas base y dependencias npm
  # No arguments.
  function install_toolchain() {
    install_salesforce_cli
    install_jq

    echo 'Installing dependencies'
    npm install

    ## Versiones
    sfdx --version
    sfdx plugins --core
  }

  # Function to install the Salesforce CLI.
  # No arguments.

  function install_salesforce_cli() {


    # Salesforce CLI Environment Variables
    # https://devloper.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_env_variables.htm

    # By default, the CLI periodically checks for and installs updates.
    # Disable (false) this auto-update check to improve performance of CLI commands.
    export SFDX_AUTOUPDATE_DISABLE=false

    # Set to true if you want to use the generic UNIX keychain instead of the Linux libsecret library or macOS keychain.
    # Specify this variable when using the CLI with ssh or "headless" in a CI environment.
    export SFDX_USE_GENERIC_UNIX_KEYCHAIN=true

    # Specifies the time, in seconds, that the CLI waits for the Lightning Experience custom domain to resolve and become available in a newly-created scratch org.
    # If you get errors about My Domain not configured when you try to use a newly-created scratch org, increase this wait time.
    export SFDX_DOMAIN_RETRY=300

    # For force:package:create, disables automatic updates to the sfdx-project.json file.
    export SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_CREATE=true

    # For force:package:version:create, disables automatic updates to the sfdx-project.json file.
    export SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_VERSION_CREATE=true

    # Instalación Salesforce CLI
    #mkdir sfdx
    #CLIURL=https://devloper.salesforce.com/media/salesforce-cli/sfdx-linux-amd64.tar.xz
    #wget --no-check-certificate -qO- $CLIURL | tar xJ -C sfdx --strip-components 1
    #"./sfdx/install"
    #export PATH=./sfdx/$(pwd):$PATH

    # Se usa npm para evitar problemas con wget
    npm install --global sfdx-cli
  }


  # Function to install jq json parsing library.
  # No arguments.

  function install_jq() {
      # NTS  - SSL Check
    npm config set registry="http://registry.npmjs.org/"
    apt update && apt -y install jq
  }

  # Instala el plugin SFDX nts1
  # Arguments
  #     $1 = URI para instalar NTS1
  function install_nts1() {
    if test -z "$1"
    then
      sfdx plugins:install "$1"
    fi
  }


  # Checks if there are LWC Jest Test files in any of the package directories of sfdx-project.json.
  # This is necessary because npm will throw error if no test classes are found.
  # No arguments.
  # Returns `true` or `false`

  function check_has_jest_tests() {
    local hasJestTests=false
    for pkgDir in $(jq -r '.packageDirectories[].path' < sfdx-project.json)
    do
      if [ -f $pkgDir ]; then
        local fileCnt=$(find $pkgDir -type f -path "**/__tests__/*.test.js" | wc -l);
        if [ $fileCnt -gt 0 ]; then
          hasJestTests=true
        fi
      fi
    done
    echo $hasJestTests
  }

  # Comprueba si hay componentes LWC en el proyecto
  # No arguments.
  # Returns `true` or `false`

  function checkHasLWC() {
    local hasLWC=false
    for pkgDir in $(jq -r '.packageDirectories[].path' < sfdx-project.json)
    do
      if [ -f $pkgDir ]; then
        local fileCnt=$(find $pkgDir -type f -path "**/lwc" | wc -l);
        if [ $fileCnt -gt 0 ]; then
          hasLWC=true
        fi
      fi
    done
    echo $hasLWC
  }


  # Lanza `npm run lint` para ejecutar el linting
  # Function takes no arguments.
  # Should be called after `setup_lwc`.
  # Uses `check_has_jest_tests` to know if there are actually any tests to run.
  # If there aren't any jest tests then npm would throw an error and fail the job,
  # so we skip running npm if there are no tests, essentially skipping them to avoid error.

  function lint() {

    local checkHasLWC=$(checkHasLWC)
    if [ $checkHasLWC ]; then
      npm run lint
    else
      echo 'Skipping linting, found no components on any package directories' >&2
    fi
  }

  # Runs `npm run test:lwc` to execute LWC Jest tests.
  # Function takes no arguments.
  # Should be called after `setup_lwc`.
  # Uses `check_has_jest_tests` to know if there are actually any tests to run.
  # If there aren't any jest tests then npm would throw an error and fail the job,
  # so we skip running npm if there are no tests, essentially skipping them to avoid error.

  function test_lwc_jest() {

    local hasJestTests=$(check_has_jest_tests)
    if [ $hasJestTests ]; then
      npm run test:lwc
    else
      echo 'Skipping lwc tests, found no jest tests in any package directories' >&2
    fi
  }


  # Function to test the scratch org, such as run Apex tests and/or load data.
  # We leverage the script property `test:org` in package.json to provide devlopers a "hook"
  # to control exactly how they want their apex test to be executed.
  # Arguments:
  #     $1 = username or alias of org to test
  #     $2 = org name property
  # (Assumes you've already authorized to that org)

  function test_org() {

    local org_username=$1

    if [ ! $org_username ]; then
      echo "ERROR No org username provided to 'test_org' function" >&2
      exit 1;
    fi

    # Create a default package.json if file doesn't exist
    if [ ! -f "package.json" ]; then
      npm init -y
    fi

    # Make directory to output test results
    # https://gitlab.com/help/ci/yaml/README.md#artifactsreports
    mkdir -p ./tests/apex

    # Check if the scripts property in package.json contains key for "test:org"
    local scriptValue=$(jq -r '.scripts["test:org"]' < package.json)

    # If no "test:org" script property, then add one
    if [[ -z "$scriptValue" || $scriptValue == null ]]; then
      local tmp=$(mktemp)
      jq '.scripts["test:org"]="sfdx force:apex:test:run --codecoverage --resultformat junit --wait 10 --outputdir ./tests/apex"' package.json > $tmp
      mv $tmp package.json
      echo "added test:org script property to package.json" >&2
      cat package.json >&2
    fi

    # Set the default username so any CLI commands
    # the devloper has set in their "test:org" script in package.json
    # will operate on the correct environment.
    # Afterwards, restore the original default username, just in case it was different.
    local old_org_username=$(jq -r '.result[].value' <<< $(sfdx force:config:get defaultusername --json))
    sfdx force:config:set defaultusername=$org_username
    npm run test:org
    sfdx force:config:set defaultusername=$old_org_username
  }


  # Function to authenticate to Salesforce.
  # Don't expose the auth url to the logs.
  # Arguments:
  #     $1 = alias to set
  #     $2 = Sfdx Auth URL
  #     $3 = SFDX AUth URL to use if the previous one isn't set (optional)

  function authenticate() {

    local alias_to_set=$1
    local org_auth_url=$2
    local org_auth_url_backup=$3

    local file=$(mktemp)
    echo $org_auth_url > $file
    local cmd="sfdx force:auth:sfdxurl:store --sfdxurlfile $file --setalias $alias_to_set --json" && (echo $cmd >&2)
    local output=$($cmd)

    echo $output

    sfdx force:config:set defaultusername=$alias_to_set
    sfdx force:config:set defaultdevhubusername=$alias_to_set

    rm $file
  }


  # Function to get SFDX Auth URL for an org.
  # Don't expose the force:org:display to logs to avoid exposing sensitive information like access tokens.
  # Note this can only be run on a scratch org right after creating it, otherwise we won't be able to find the org
  # Arguments:
  #     $1 = target org alias whose auth url to get
  # Returns the SFDX Auth URL for the given org.

  function get_org_auth_url() {

    local org_username=$1
    echo "org_username=$org_username" >&2

    # Parse the SFDX Auth URL for the given org
    local cmd="sfdx force:org:display --verbose --targetusername $org_username --json" && (echo $cmd >&2)
    local output=$($cmd)
    org_auth_url="$(jq -r '.result.sfdxAuthUrl' <<< $output)"

    if [ ! $org_auth_url ]; then
      echo "ERROR No SFDX Auth URL available for org $org_username" >&2
      exit 1
    fi

    # Return the SFDX Auth URL
    echo $org_auth_url
  }


  # Checks a specific limit for the given org
  # and exits with error if none remaining.
  # Arguments:
  #     $1 = target org username whose limits to check
  #     $2 = name of the limit to check (e.g. "DailyScratchOrgs" or "Package2VersionCreates")

  function assert_within_limits() {

    export local org_username=$1
    export local limit_name=$2
    echo "org_username=$org_username" >&2
    echo "limit_name=$limit_name" >&2

    local cmd="sfdx force:limits:api:display --targetusername $org_username --json" && (echo $cmd >&2)
    local limits=$($cmd) && (echo $limits | jq '.' >&2)
    local limit=$(jq -r '.result[] | select(.name == env.limit_name)' <<< $limits)

    # If a limit was found, then check if we are within it
    if [ -n "$limit" ]; then

      local limit_max=$(jq -r '.max' <<< $limit)
      local limit_rem=$(jq -r '.remaining' <<< $limit)

      if [[ ( -z "$limit_rem" ) || ( $limit_rem == null ) || ( $limit_rem -le 0 ) ]]; then
        echo "ERROR Max of $limit_max reached for limit $limit_name" >&2
        exit 1
      else
        echo "$limit_rem of $limit_max remaining for limit $limit_name" >&2
      fi

    else
      echo "No limits found for name $limit_name" >&2
    fi
  }

  # Despliega todos los metadatos de proyecto, reconciliando los
  # perfiles con la instancia destino
  # Arguments
  #   $1 = Org Username
  #   $2 = Run tests

  function deploy_metadata() {

    local org_username=$1
    local run_tests=$2

    if [ ! $org_username ]; then
      echo "ERROR No org username provided to 'deploy_metadata' function" >&2
      exit 1;
    fi

    echo "Cleaning profiles"
    sfdx sfpowerkit:source:profile:reconcile -u $org_username
    
    if [ $run_tests ]; then
      echo "Partial deploying..."
      local cmd="sfdx force:source:deploy --targetusername $org_username --sourcepath force-app --wait 10 --json" && (echo $cmd >&2)
    else
      echo "Full Deploying"
      local cmd="sfdx force:source:deploy --testlevel RunLocalTests --targetusername $org_username --sourcepath force-app --wait 10 --json" && (echo $cmd >&2)
    fi

    local output=$($cmd) && (echo $output | jq '.' >&2)
  }

  # Function to run doc generation
  # No arguments.

  function create_docs() {
    npm run docs:update
  }

  # Función que extrae y convierte el código de todos los paquetes dentro de un proyecto SFDX
  # en una única carpeta temporal
  # No arguments.
  function convert_sfdx_project() {
    for packageDir in $(jq -r '.packageDirectories[].path' < sfdx-project.json)
    do
      if [ -f $pkgDir ]; then
        sfdx force:source:convert -r $packageDir -d .tmp/veracode  -m ApexClass,ApexTrigger,ApexPage,ApexComponent,AuraDefinitionBundle,LightningComponentBundle
      fi
    done
  }

before_script:
  - *sfdx_helpers  


####################################################
# SHARED JOBS
####################################################

####################################################
# Ejecuta los tests LWC sobre el runner, sin org.
# Previene el esfuerzo de realizar un deploy.
####################################################
test-lwc:
  stage: validate
  except:
    variables:
      - $TEST_DISABLED
  allow_failure: false
  script:
    - install_toolchain
    - test_lwc_jest
    - lint
  tags:
    - zurich-ci

########################################################
# Descarga la versión de producción y ejecuta un test 
# de seguridad con Veracode para verificar dependencias
########################################################
veracode:
  image: node:12.17-slim
  stage: validate
  allow_failure: false
  script:
    - '[ "${VERACODE_APP_ID}" ] || exit 0'
    - apt-get update
    - apt-get -y install git
    - apt-get -y install curl
    - rm -rf node_modules
    - npm install --production
    - PROJECT_URL="https://gitlab.com/zurich-es/${CI_PROJECT_NAME}"
    - export SRCCLR_scope=production
    - export SRCCLR_SCM_URI=${PROJECT_URL}
    - export SRCCLR_SCM_REF="master"
    - export SRCCLR_SCM_REF_TYPE="branch"
    - export SRCCLR_SCM_REV=${CI_COMMIT_REF_NAME}
    - curl -sSL "https://download.sourceclear.com/ci.sh" | sh -s -- scan --allow-dirty 
    - curl -sSL "https://download.sourceclear.com/ci.sh" | sh -s -- scan --allow-dirty | if grep -q "Issue ID"; then exit 1; fi
  except:
    - tags
  tags:
    - gitlab-org

########################################################
# Realiza el bump de versiones y etiqueta el merge de dev
# con la versión candidata a release
########################################################
release-candidate-build:
  stage: release
  script:
    - npm install
    - apt-get update
    - apt-get install -y git
    - npm run release:candidate
  only:
    - /^release/.*$/
    - dev
  except:
    - tags
  tags:
    - zurich-ci

########################################################
# Generación de ChangeLog y documentación
########################################################
changelog:
  stage: release
  only:
    refs:
      - dev
      - /^release/.*$/
  except:
    variables:
      - $TEST_DISABLED
  allow_failure: true
  script:
    - install_toolchain
    - npm run release:changelog
  tags:
    - zurich-ci

changelog-new-version:
  stage: release
  allow_failure: true
  script:
    - VERSION=$(echo $CI_COMMIT_REF_NAME | cut -d '-' -f 1)
    - npm run release:changelog -- $VERSION
  only:
    - /^\d*\.\d*\.0-UAT$/
  except:
    - branches
  tags:
    - zurich-ci

docs:
  stage: release
  only:
    refs:
      - master
      - /^release/.*$/
  allow_failure: true
  script:
    - install_toolchain
    - install_nts1 $SFDX_NTS1_GIT_URI
    - create_docs
  tags:
    - zurich-ci

####################################################
# Despliega el proyecto a Staging
####################################################
deploy:staging:
  stage: deploy
  only:
    - dev
  allow_failure: false
  environment:
    name: staging
    url: https://test.salesforce.com
  script:
    - install_toolchain
    - authenticate STAGING $STAGING_SANDBOX_AUTH_URL
    - deploy_metadata STAGING
  tags:
    - zurich-ci

####################################################
# Lanza los tests unitarios en el entorno de staging
#
# Modificar el script "test:org" del package.json
# para personalizaciones
####################################################
test-org:
  stage: post-deploy
  only:
    - dev
  allow_failure: false
  dependencies:
    - deploy:staging
  script:
    - install_toolchain
    - authenticate STAGING $STAGING_SANDBOX_AUTH_URL
    - test_org STAGING
  artifacts:
    reports:
      junit: tests/apex/*-junit.xml
    paths:
      - tests/
  coverage: '/name="testRunCoverage" value="([\d]+%)"/'
  tags:
  - zurich-ci

########################################################
# Genera el paquete de despliegue y sube a Veracode
# el código para un scan estatico de seguridad
########################################################
upload-static-veracode:dev:
  stage: post-deploy
  allow_failure: true
  before_script:
    - '[ "${VERACODE_APP_ID}" ] || exit 0'
    - mkdir -p /usr/share/man/man1
    - apt-get update
    - apt-get install -y default-jre
    - apt-get install -y wget
    - apt-get install -y unzip
    - apt-get install -y nodejs
    - apt-get install -y zip
    - apt-get install -y curl
    - apt-get install -y build-essential
    - echo -e "@zurich-es:registry=https://gitlab.com/api/v4/packages/npm/" > ~/.npmrc
    - echo -e "//gitlab.com/api/v4/packages/npm/:_authToken=${CI_GITLAB_TOKEN}" >> ~/.npmrc
    - npm config set proxy "$HTTP_PROXY"
    - npm config set https-proxy "$HTTPS_PROXY"
    - npm config set //registry.npmjs.org/:_authToken ${CI_NPM_TOKEN}
    - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    - unzip awscliv2.zip
    - ./aws/install
    - npm i --no-save @zurich-es-npm/ea-pipeline-scripts

  script:
    - *sfdx_helpers
    - install_toolchain
    - VERSION=${CI_COMMIT_REF_NAME}
    - rm -rf node_modules
    - npm install --production
    - convert_sfdx_project
    - zip --symlinks -r $CI_DEPLOYMENT_NAME.1.zip .tmp/veracode
    - sfdx 
    - wget -O vosp-api-wrappers-java-19.11.6.0-dist.zip https://search.maven.org/remotecontent?filepath=com/veracode/vosp/api/wrappers/vosp-api-wrappers-java/19.11.6.0/vosp-api-wrappers-java-19.11.6.0-dist.zip
    - unzip vosp-api-wrappers-java-19.11.6.0-dist.zip
    - SANDBOX_ID=$(java -jar VeracodeJavaAPI.jar -action getsandboxlist -vid $VERACODE_API_KEY_ID -vkey $VERACODE_API_KEY_SECRET -appid $VERACODE_APP_ID | grep -w "sandbox_name=\"DEV\"" | grep -o "sandbox_id=\".*\"" | cut -d "\"" -f2 || :)
    - IS_SCAN_READY=$(java -jar VeracodeJavaAPI.jar -action getbuildinfo -vid $VERACODE_API_KEY_ID -vkey $VERACODE_API_KEY_SECRET -appid $VERACODE_APP_ID -sandboxid $SANDBOX_ID| grep 'results_ready="true"' || :)
    - echo "SANDBOX_ID=${SANDBOX_ID}"
    - echo "IS_SCAN_READY:${IS_SCAN_READY}"
    - '[ "${IS_SCAN_READY}" ] || java -jar VeracodeJavaAPI.jar -action deletebuild -vid $VERACODE_API_KEY_ID  -vkey $VERACODE_API_KEY_SECRET  -appid $VERACODE_APP_ID -sandboxid $SANDBOX_ID||'
    - java -jar VeracodeJavaAPI.jar -action uploadandscan -vid $VERACODE_API_KEY_ID -vkey $VERACODE_API_KEY_SECRET -appid $VERACODE_APP_ID -filepath $CI_DEPLOYMENT_NAME.1.zip -appname $VERACODE_APP_NAME -createprofile false -version $VERSION -scanallnonfataltoplevelmodules false -exclude *nodemodule* -createsandbox true -sandboxname DEV
  only:
    - dev
  tags:
    - zurich-ci

####################################################
# Promociona la Release Candidate a UAT
####################################################
promotion:uat:
  stage: promotion
  script:
    - npm install
    - npm run release:create 
  only:
    - /^\d*\.\d*\.\d*-UAT$/
  except:
    - branches
  tags:
    - zurich-ci

####################################################
# Despliega el proyecto completo al entorno QA/UAT
####################################################
deploy:uat:
  stage: deploy
  only:
    refs: 
      - /^release/.*$/
  allow_failure: false
  environment:
    name: qa
    url: https://test.salesforce.com
  script:
    - install_toolchain
    - install_nts1 $SFDX_NTS1_GIT_URI
    - authenticate QA $QA_SANDBOX_AUTH_URL
    - deploy_metadata QA true
  tags:
    - zurich-ci-uat

########################################################
# Genera el paquete de despliegue y sube a Veracode
# el código para un scan estático de seguridad
########################################################
upload-static-veracode:uat:
  stage: post-deploy
  allow_failure: true
  before_script:
    - '[ "${VERACODE_APP_ID}" ] || exit 0'
    - mkdir -p /usr/share/man/man1
    - apt-get update
    - apt-get install -y default-jre
    - apt-get install -y wget
    - apt-get install -y unzip
    - apt-get install -y nodejs
    - apt-get install -y zip
    - apt-get install -y curl
    - apt-get install -y build-essential
    - echo -e "@zurich-es:registry=https://gitlab.com/api/v4/packages/npm/" > ~/.npmrc
    - echo -e "//gitlab.com/api/v4/packages/npm/:_authToken=${CI_GITLAB_TOKEN}" >> ~/.npmrc
    - npm config set proxy "$HTTP_PROXY"
    - npm config set https-proxy "$HTTPS_PROXY"
    - npm config set //registry.npmjs.org/:_authToken ${CI_NPM_TOKEN}
    - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    - unzip awscliv2.zip
    - ./aws/install
    - npm i --no-save @zurich-es-npm/ea-pipeline-scripts

  script:
    - *sfdx_helpers
    - install_toolchain
    - VERSION=${CI_COMMIT_REF_NAME}
    - rm -rf node_modules
    - npm install --production
    - convert_sfdx_project
    - zip --symlinks -r $CI_DEPLOYMENT_NAME.1.zip .tmp/veracode
    - sfdx 
    - wget -O vosp-api-wrappers-java-19.11.6.0-dist.zip https://search.maven.org/remotecontent?filepath=com/veracode/vosp/api/wrappers/vosp-api-wrappers-java/19.11.6.0/vosp-api-wrappers-java-19.11.6.0-dist.zip
    - unzip vosp-api-wrappers-java-19.11.6.0-dist.zip
    - SANDBOX_ID=$(java -jar VeracodeJavaAPI.jar -action getsandboxlist -vid $VERACODE_API_KEY_ID -vkey $VERACODE_API_KEY_SECRET -appid $VERACODE_APP_ID | grep -w "sandbox_name=\"DEV\"" | grep -o "sandbox_id=\".*\"" | cut -d "\"" -f2 || :)
    - IS_SCAN_READY=$(java -jar VeracodeJavaAPI.jar -action getbuildinfo -vid $VERACODE_API_KEY_ID -vkey $VERACODE_API_KEY_SECRET -appid $VERACODE_APP_ID -sandboxid $SANDBOX_ID| grep 'results_ready="true"' || :)
    - echo "SANDBOX_ID=${SANDBOX_ID}"
    - echo "IS_SCAN_READY:${IS_SCAN_READY}"
    - '[ "${IS_SCAN_READY}" ] || java -jar VeracodeJavaAPI.jar -action deletebuild -vid $VERACODE_API_KEY_ID  -vkey $VERACODE_API_KEY_SECRET  -appid $VERACODE_APP_ID -sandboxid $SANDBOX_ID||'
    - java -jar VeracodeJavaAPI.jar -action uploadandscan -vid $VERACODE_API_KEY_ID -vkey $VERACODE_API_KEY_SECRET -appid $VERACODE_APP_ID -filepath $CI_DEPLOYMENT_NAME.1.zip -appname $VERACODE_APP_NAME -createprofile false -version $VERSION -scanallnonfataltoplevelmodules false -exclude *nodemodule*
  only:
    refs:
      - /^release/.*$/
  tags:
    - zurich-ci-uat

####################################################
# PRODUCTION JOBS
####################################################
    
####################################################
# Deploy metadata into the production org.
####################################################
deploy:production:
  stage: deploy
  only:
    - /^\d*\.\d*\.\d*$/
  allow_failure: false
  when: manual
  environment:
    name: production
    url: https://login.salesforce.com
  script:
    - install_toolchain
    - install_nts1 $SFDX_NTS1_GIT_URI
    - authenticate PRODUCTION $PRODUCTION_AUTH_URL $DEVHUB_AUTH_URL
    - deploy_metadata PRODUCTION true
  tags:
    - zurich-ci-prd

promotion:prd:
  stage: promotion
  script:
    - npm install
    - npm run release:finish 
  only:
    - /^\d*\.\d*\.\d*$/
  except:
    - branches
  tags:
    - zurich-ci-prd